# 冒泡排序

什么是冒泡排序？

冒泡排序的英文**Bubble Sort**，是一种最基础的**交换排序**。

大家一定都喝过汽水，汽水中常常有许多小小的气泡，哗啦哗啦飘到上面来。这是因为组成小气泡的二氧化碳比水要轻，所以小气泡可以一点一点向上浮动。

而我们的冒泡排序之所以叫做冒泡排序，正是因为这种排序算法的每一个元素都可以像小气泡一样，根据自身大小，一点一点向着数组的一侧移动。

具体如何来移动呢？让我们来看一个栗子：

有8个数组成一个无序数列：5，8，6，3，9，2，1，7，希望从小到大排序。

按照冒泡排序的思想，我们要把**相邻的元素两两比较，根据大小来交换元素的位置**，过程如下：

首先让5和8比较，发现5比8要小，因此元素位置不变。

接下来让8和6比较，发现8比6要大，所以8和6交换位置。

5，**6，8**，3，9，2，1，7

继续让8和3比较，发现8比3要大，所以8和3交换位置。

5，6，**3，8**，9，2，1，7

继续让8和9比较，发现8比9要小，所以元素位置不变。

接下来让9和2比较，发现9比2要大，所以9和2交换位置。

5，6，3，8，**2，9**，1，7

接下来让9和1比较，发现9比1要大，所以9和1交换位置。

5，6，3，8，2，**1，9**，7

最后让9和7比较，发现9比7要大，所以9和7交换位置。

5，6，3，8，2，1，**7，9**

这样一来，元素9作为数列的最大元素，就像是汽水里的小气泡一样漂啊漂，漂到了最右侧。

这时候，我们的冒泡排序的第一轮结束了。数列最右侧的元素9可以认为是一个有序区域，有序区域目前只有一个元素。

5，6，3，8，2，1，7，_9_

下面，让我们来进行第二轮排序：

首先让5和6比较，发现5比6要小，因此元素位置不变。

接下来让6和3比较，发现6比3要大，所以6和3交换位置。

5，**3，6**，8，2，1，7，_9_

继续让6和8比较，发现6比8要小，因此元素位置不变。

接下来让8和2比较，发现8比2要大，所以8和2交换位置。

5，3，6，**2，8**，1，7，_9_

接下来让8和1比较，发现8比1要大，所以8和1交换位置。

5，3，6，2，**1，8**，7，_9_

继续让8和7比较，发现8比7要大，所以8和7交换位置。

5，3，6，2，1，**7，8**，_9_

第二轮排序结束后，我们数列右侧的有序区有了两个元素，顺序如下：

5，3，6，2，1，7，_8，9_

至于后续的交换细节，我们这里就不详细描述了

3，5，2，1，6，_7，8，9_

3，2，1，5，_6，7，8，9_

2，1，3，_5，6，7，8，9_

_1，2，3，5，6，7，8，9_

到此为止，所有元素都是有序的了，这就是冒泡排序的整体思路。

原始的冒泡排序是**稳定排序**。由于该排序算法的每一轮要遍历所有元素，轮转的次数和元素数量相当，所以时间复杂度是**O（N^2）** 。

**冒泡排序第一版：**

```text
    private static void sort(int[] array) {
        int tmp = 0;
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
                }
            }
        }
    }


    public static void main(String[] args) {
        int[] array = new int[]{5, 8, 6, 3, 9, 2, 1, 7};
        sort(array);
        System.out.println(Arrays.toString(array));
    }
```

代码非常简单，使用双循环来进行排序。外部循环控制所有的回合，内部循环代表每一轮的冒泡处理，先进行元素比较，再进行元素交换。

原始的冒泡排序有哪些优化点呢？

让我们回顾一下刚才描述的排序细节，仍然以5，8，6，3，9，2，1，7这个数列为例，当排序算法分别执行到第六、第七、第八轮的时候，数列状态如下：

_1，2，3，5，6，7，8，9_

很明显可以看出，自从经过第六轮排序，整个数列已然是有序的了。可是我们的排序算法仍然“兢兢业业”地继续执行第七轮、第八轮。

这种情况下，如果我们能判断出数列已经有序，并且做出标记，剩下的几轮排序就可以不必执行，提早结束工作。

**冒泡排序第二版**

```text
    private static void sort(int[] array) {
        int tmp = 0;
        for (int i = 0; i < array.length; i++) {
            //有序标记，每一轮的初始是true
            boolean isSorted = true;
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
                    //有元素交换，所以不是有序，标记变为false
                    isSorted = false;
                }
            }
            if(isSorted){
                break;
            }
        }
    }


    public static void main(String[] args) {
        int[] array = new int[]{5, 8, 6, 3, 9, 2, 1, 7};
        sort(array);
        System.out.println(Arrays.toString(array));
    }
```

这一版代码做了小小的改动，利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。

为了说明问题，咱们这次找一个新的数列：

3,4,2,1,5,6,7,8

这个数列的特点是前半部分（3，4，2，1）无序，后半部分（5，6，7，8）升序，并且后半部分的元素已经是数列最大值。

让我们按照冒泡排序的思路来进行排序，看一看具体效果：

**第一轮**

元素3和4比较，发现3小于4，所以位置不变。

元素4和2比较，发现4大于2，所以4和2交换。

3,2,4,1,5,6,7,8

元素4和1比较，发现4大于1，所以4和1交换。

3,2,1,4,5,6,7,8

元素4和5比较，发现4小于5，所以位置不变。

元素5和6比较，发现5小于6，所以位置不变。

元素6和7比较，发现6小于7，所以位置不变。

元素7和8比较，发现7小于8，所以位置不变。

第一轮结束，数列有序区包含一个元素：

**第二轮**

元素3和2比较，发现3大于2，所以3和2交换。

2,3,1,4,5,6,7,8

元素3和1比较，发现3大于1，所以3和1交换。

2,1,3,4,5,6,7,8

元素3和4比较，发现3小于4，所以位置不变。

元素4和5比较，发现4小于5，所以位置不变。

元素5和6比较，发现5小于6，所以位置不变。

元素6和7比较，发现6小于7，所以位置不变。

元素7和8比较，发现7小于8，所以位置不变。

第二轮结束，数列有序区包含一个元素：

  
这个问题的关键点在哪里呢？关键在于对数列有序区的界定。

按照现有的逻辑，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2 ......

实际上，数列真正的有序区可能会大于这个长度，比如例子中仅仅第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。

如何避免这种情况呢？我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。

**冒泡排序第三版**

\*\*\*\*

```text
private static void sort(int[] array) {
    int tmp = 0;
    //记录最后一次交换的位置
    int lastExchangeIndex = 0;
    //无序数列的边界，每次比较只需要比到这里为止
    int sortBorder = array.length - 1;
    for (int i = 0; i < array.length; i++) {
        //有序标记，每一轮的初始是true
        boolean isSorted = true;
        for (int j = 0; j < sortBorder; j++) {
            if (array[j] > array[j + 1]) {
                tmp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = tmp;
                //有元素交换，所以不是有序，标记变为false
                isSorted = false;
                //把无序数列的边界更新为最后一次交换元素的位置
                lastExchangeIndex = j;
            }
        }
        sortBorder = lastExchangeIndex;
        if (isSorted) {
            break;
        }
    }
}


public static void main(String[] args) {
    int[] array = new int[]{5, 8, 6, 3, 9, 2, 1, 7};
    sort(array);
    System.out.println(Arrays.toString(array));
}
```

 这一版代码中，sortBorder就是无序数列的边界。每一轮排序过程中，sortBorder之后的元素就完全不需要比较了，肯定是有序的。



